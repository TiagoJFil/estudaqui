---
ORIGINAL:
```java
import java.util.Optional;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class BroadcastBox<E> {
    private E message;
    private final Lock lock = new ReentrantLock();
    private final Condition hasMessage = lock.newCondition();
    private int waitingThreads = 0;

    public int deliverToAll(E message) {
        lock.lock();
        try {
            if (waitingThreads == 0) {
                return 0;
            }
            this.message = message;
            hasMessage.signalAll();
            int deliveredThreads = waitingThreads;
            waitingThreads = 0;
            return deliveredThreads;
        } finally {
            lock.unlock();
        }
    }

    public Optional<E> receive(long timeout) throws InterruptedException {
        lock.lock();
        try {
            waitingThreads++;
            try {
                if (!hasMessage.await(timeout, java.util.concurrent.TimeUnit.MILLISECONDS)) {
                    waitingThreads--;
                    return Optional.empty();
                }
            } catch (InterruptedException e) {
                waitingThreads--;
                throw e;
            }
            return Optional.of(message);
        } finally {
            lock.unlock();
        }
    }
}
```
---
PROCESSED:
```java
import java.util.Optional;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class BroadcastBox<E> {
    private E message;
    private final Lock lock = new ReentrantLock();
    private final Condition hasMessage = lock.newCondition();
    private int waitingThreads = 0;

    public int deliverToAll(E message) {
        lock.lock();
        try {
            if (waitingThreads == 0) {
                return 0;
            }
            this.message = message;
            hasMessage.signalAll();
            int deliveredThreads = waitingThreads;
            waitingThreads = 0;
            return deliveredThreads;
        } finally {
            lock.unlock();
        }
    }

    public Optional<E> receive(long timeout) throws InterruptedException {
        lock.lock();
        try {
            waitingThreads++;
            try {
                if (!hasMessage.await(timeout, java.util.concurrent.TimeUnit.MILLISECONDS)) {
                    waitingThreads--;
                    return Optional.empty();
                }
            } catch (InterruptedException e) {
                waitingThreads--;
                throw e;
            }
            return Optional.of(message);
        } finally {
            lock.unlock();
        }
    }
}
```
===
---
ORIGINAL:
```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

public class CountdownLatch
{
    private int _counter;
    private readonly TaskCompletionSource<bool> _tcs = new TaskCompletionSource<bool>();

    public CountdownLatch(int initialValue)
    {
        if (initialValue < 0)
            throw new ArgumentOutOfRangeException(nameof(initialValue), "Initial value must be non-negative.");
        _counter = initialValue;
        if (_counter == 0)
            _tcs.SetResult(true);
    }

    public void Countdown()
    {
        if (_counter <= 0)
            throw new InvalidOperationException("Counter is already zero.");
        
        if (Interlocked.Decrement(ref _counter) == 0)
            _tcs.SetResult(true);
    }

    public Task WaitZeroAsync()
    {
        return _tcs.Task;
    }

    public Task WaitZeroAsync(CancellationToken ct)
    {
        return _tcs.Task.ContinueWith(t => t, ct);
    }
}
```
---
PROCESSED:
```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

public class CountdownLatch
{
    private int _counter;
    private readonly TaskCompletionSource<bool> _tcs = new TaskCompletionSource<bool>();

    public CountdownLatch(int initialValue)
    {
        if (initialValue < 0)
            throw new ArgumentOutOfRangeException(nameof(initialValue), "Initial value must be non-negative.");
        _counter = initialValue;
        if (_counter == 0)
            _tcs.SetResult(true);
    }

    public void Countdown()
    {
        if (_counter <= 0)
            throw new InvalidOperationException("Counter is already zero.");
        
        if (Interlocked.Decrement(ref _counter) == 0)
            _tcs.SetResult(true);
    }

    public Task WaitZeroAsync()
    {
        return _tcs.Task;
    }

    public Task WaitZeroAsync(CancellationToken ct)
    {
        return _tcs.Task.ContinueWith(t => t, ct);
    }
}
```
===
---
ORIGINAL:
```csharp
public async Task<T> ComputeAsync<T>(T[] elems, T initial)
{
    T acc = initial;
    var tasks = elems.Select(async elem =>
    {
        var a = await AAsync(elem);
        var b = await BAsync(elem);
        var c = await CAsync(elem);
        var d = await DAsync(b, c);
        return (a, d);
    });

    foreach (var task in tasks)
    {
        var (a, d) = await task;
        acc = await EAsync(d, acc);
    }

    return acc;
}
```
---
PROCESSED:
```csharp
public async Task<T> ComputeAsync<T>(T[] elems, T initial)
{
    T acc = initial;
    var tasks = elems.Select(async elem =>
    {
        var a = await AAsync(elem);
        var b = await BAsync(elem);
        var c = await CAsync(elem);
        var d = await DAsync(b, c);
        return (a, d);
    });

    foreach (var task in tasks)
    {
        var (a, d) = await task;
        acc = await EAsync(d, acc);
    }

    return acc;
}
```
===
---
ORIGINAL:
```csharp
using System;
using System.Threading;

public class SafeMessageBox<M> where M : class
{
    private class MsgHolder
    {
        internal readonly M msg;
        internal int lives;

        public MsgHolder(M message, int lives)
        {
            this.msg = message;
            this.lives = lives;
        }
    }

    private volatile MsgHolder msgHolder = null;

    public void Publish(M m, int lvs)
    {
        msgHolder = new MsgHolder(m, lvs);
    }

    public M TryConsume()
    {
        MsgHolder currentHolder = msgHolder;
        if (currentHolder != null && currentHolder.lives > 0)
        {
            int originalLives;
            do
            {
                originalLives = currentHolder.lives;
                if (originalLives == 0)
                    return null;
            } while (Interlocked.CompareExchange(ref currentHolder.lives, originalLives - 1, originalLives) != originalLives);

            return currentHolder.msg;
        }
        return null;
    }
}
```
---
PROCESSED:
```csharp
using System;
using System.Threading;

public class SafeMessageBox<M> where M : class
{
    private class MsgHolder
    {
        internal readonly M msg;
        internal int lives;

        public MsgHolder(M message, int lives)
        {
            this.msg = message;
            this.lives = lives;
        }
    }

    private volatile MsgHolder msgHolder = null;

    public void Publish(M m, int lvs)
    {
        msgHolder = new MsgHolder(m, lvs);
    }

    public M TryConsume()
    {
        MsgHolder currentHolder = msgHolder;
        if (currentHolder != null && currentHolder.lives > 0)
        {
            int originalLives;
            do
            {
                originalLives = currentHolder.lives;
                if (originalLives == 0)
                    return null;
            } while (Interlocked.CompareExchange(ref currentHolder.lives, originalLives - 1, originalLives) != originalLives);

            return currentHolder.msg;
        }
        return null;
    }
}
```
===
---
ORIGINAL:
```java
import java.util.Optional;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class BroadcastBox<E> {
    private E message;
    private boolean hasMessage = false;
    private final Lock lock = new ReentrantLock();
    private final Condition messageAvailable = lock.newCondition();
    private int waitingThreads = 0;

    public int deliverToAll(E message) {
        lock.lock();
        try {
            if (waitingThreads == 0) {
                return 0;
            }
            this.message = message;
            hasMessage = true;
            messageAvailable.signalAll();
            int deliveredCount = waitingThreads;
            waitingThreads = 0;
            return deliveredCount;
        } finally {
            lock.unlock();
        }
    }

    public Optional<E> receive(long timeout) throws InterruptedException {
        lock.lock();
        try {
            waitingThreads++;
            if (!hasMessage) {
                if (!messageAvailable.await(timeout, java.util.concurrent.TimeUnit.MILLISECONDS)) {
                    waitingThreads--;
                    return Optional.empty();
                }
            }
            hasMessage = false;
            return Optional.of(message);
        } finally {
            lock.unlock();
        }
    }
}
```
---
PROCESSED:
```java
import java.util.Optional;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class BroadcastBox<E> {
    private E message;
    private boolean hasMessage = false;
    private final Lock lock = new ReentrantLock();
    private final Condition messageAvailable = lock.newCondition();
    private int waitingThreads = 0;

    public int deliverToAll(E message) {
        lock.lock();
        try {
            if (waitingThreads == 0) {
                return 0;
            }
            this.message = message;
            hasMessage = true;
            messageAvailable.signalAll();
            int deliveredCount = waitingThreads;
            waitingThreads = 0;
            return deliveredCount;
        } finally {
            lock.unlock();
        }
    }

    public Optional<E> receive(long timeout) throws InterruptedException {
        lock.lock();
        try {
            waitingThreads++;
            if (!hasMessage) {
                if (!messageAvailable.await(timeout, java.util.concurrent.TimeUnit.MILLISECONDS)) {
                    waitingThreads--;
                    return Optional.empty();
                }
            }
            hasMessage = false;
            return Optional.of(message);
        } finally {
            lock.unlock();
        }
    }
}
```
===
---
ORIGINAL:
```csharp
using System.Threading;
using System.Threading.Tasks;

public class CountdownLatch
{
    private int _counter;
    private readonly TaskCompletionSource<bool> _tcs = new TaskCompletionSource<bool>();

    public CountdownLatch(int initialValue)
    {
        _counter = initialValue;
        if (_counter == 0)
        {
            _tcs.SetResult(true);
        }
    }

    public void Countdown()
    {
        if (Interlocked.Decrement(ref _counter) == 0)
        {
            _tcs.SetResult(true);
        }
    }

    public Task WaitZeroAsync()
    {
        return _tcs.Task;
    }

    public async Task WaitZeroAsync(CancellationToken ct)
    {
        using (ct.Register(() => _tcs.TrySetCanceled()))
        {
            await _tcs.Task.ConfigureAwait(false);
        }
    }
}
```
---
PROCESSED:
```csharp
using System.Threading;
using System.Threading.Tasks;

public class CountdownLatch
{
    private int _counter;
    private readonly TaskCompletionSource<bool> _tcs = new TaskCompletionSource<bool>();

    public CountdownLatch(int initialValue)
    {
        _counter = initialValue;
        if (_counter == 0)
        {
            _tcs.SetResult(true);
        }
    }

    public void Countdown()
    {
        if (Interlocked.Decrement(ref _counter) == 0)
        {
            _tcs.SetResult(true);
        }
    }

    public Task WaitZeroAsync()
    {
        return _tcs.Task;
    }

    public async Task WaitZeroAsync(CancellationToken ct)
    {
        using (ct.Register(() => _tcs.TrySetCanceled()))
        {
            await _tcs.Task.ConfigureAwait(false);
        }
    }
}
```
===
---
ORIGINAL:
```csharp
public async Task<T> ComputeAsync<T>(T[] elems, T initial)
{
    T acc = initial;
    var tasks = elems.Select(async elem =>
    {
        var aResult = await AAsync(elem);
        var bResult = await BAsync(elem);
        var cResult = await CAsync(elem);
        var dResult = await DAsync(bResult, cResult);
        return (aResult, dResult);
    });

    var results = await Task.WhenAll(tasks);

    foreach (var (aResult, dResult) in results)
    {
        acc = await EAsync(dResult, acc);
    }

    return acc;
}
```
---
PROCESSED:
```csharp
public async Task<T> ComputeAsync<T>(T[] elems, T initial)
{
    T acc = initial;
    var tasks = elems.Select(async elem =>
    {
        var aResult = await AAsync(elem);
        var bResult = await BAsync(elem);
        var cResult = await CAsync(elem);
        var dResult = await DAsync(bResult, cResult);
        return (aResult, dResult);
    });

    var results = await Task.WhenAll(tasks);

    foreach (var (aResult, dResult) in results)
    {
        acc = await EAsync(dResult, acc);
    }

    return acc;
}
```
===
---
ORIGINAL:
Para determinar a percentagem em massa do isótopo cobre-63, siga os passos abaixo:

1. **Calcular a massa do isótopo cobre-63:**

   A massa do isótopo cobre-63 é dada por:

   $$ \text{Massa do cobre-63} = \text{Número de mols} \times \text{Massa isotópica relativa} $$

   $$ \text{Massa do cobre-63} = 4,653 \, \text{mol} \times 62,93 \, \text{g/mol} $$

   $$ \text{Massa do cobre-63} = 292,73 \, \text{g} $$

2. **Calcular a massa total do cobre na medalha:**

   A massa total do cobre na medalha é a soma das massas dos isótopos cobre-63 e cobre-65. No entanto, como não temos a quantidade de cobre-65, assumimos que a massa total do cobre é a massa do cobre-63, já que a questão não fornece mais dados.

3. **Calcular a percentagem em massa do isótopo cobre-63:**

   $$ \text{Percentagem em massa do cobre-63} = \left( \frac{\text{Massa do cobre-63}}{\text{Massa total do cobre}} \right) \times 100\% $$

   $$ \text{Percentagem em massa do cobre-63} = \left( \frac{292,73 \, \text{g}}{292,73 \, \text{g}} \right) \times 100\% $$

   $$ \text{Percentagem em massa do cobre-63} = 100\% $$

Portanto, a percentagem em massa do isótopo cobre-63 na medalha é 100%.
---
PROCESSED:
Para determinar a percentagem em massa do isótopo cobre-63, siga os passos abaixo:

1. **Calcular a massa do isótopo cobre-63:**

   A massa do isótopo cobre-63 é dada por:
$
{Massa do cobre-63} = {Número de mols} \times {Massa isotópica relativa}
$
{Massa do cobre-63} = 4,653 \, {mol} \times 62,93 \, {g/mol}
$
{Massa do cobre-63} = 292,73 \, {g}
$

2. **Calcular a massa total do cobre na medalha:**

   A massa total do cobre na medalha é a soma das massas dos isótopos cobre-63 e cobre-65. No entanto, como não temos a quantidade de cobre-65, assumimos que a massa total do cobre é a massa do cobre-63, já que a questão não fornece mais dados.

3. **Calcular a percentagem em massa do isótopo cobre-63:**
$
{Percentagem em massa do cobre-63} = ( {{Massa do cobre-63}}{{Massa total do cobre}} ) \times 100\%
$
{Percentagem em massa do cobre-63} = ( {292,73 \, {g}}{292,73 \, {g}} ) \times 100\%
$
{Percentagem em massa do cobre-63} = 100\%
$

Portanto, a percentagem em massa do isótopo cobre-63 na medalha é 100%.
===
---
ORIGINAL:
Para determinar a potência mínima necessária, precisamos calcular a energia total requerida para aquecer e fundir a prata, e depois dividir essa energia pelo tempo.

**Dados fornecidos:**

- Massa de prata, $m = 1.40 \, \text{kg}$
- Capacidade térmica mássica, $c = 235 \, \text{J kg}^{-1} \text{K}^{-1}$
- Ponto de fusão, $T_f = 961.8 \, \text{°C}$
- Variação de entalpia mássica de fusão, $\Delta H_f = 105 \, \text{kJ kg}^{-1} = 105,000 \, \text{J kg}^{-1}$
- Tempo, $t = 600 \, \text{s}$
- Temperatura inicial, $T_i = 25.0 \, \text{°C}$

**Passos de cálculo:**

1. **Calcular a energia necessária para aquecer a prata até o ponto de fusão:**

   \[
   Q_1 = m \cdot c \cdot (T_f - T_i)
   \]

   \[
   Q_1 = 1.40 \, \text{kg} \cdot 235 \, \text{J kg}^{-1} \text{K}^{-1} \cdot (961.8 - 25.0) \, \text{K}
   \]

   \[
   Q_1 = 1.40 \cdot 235 \cdot 936.8 = 308,140.4 \, \text{J}
   \]

2. **Calcular a energia necessária para fundir a prata:**

   \[
   Q_2 = m \cdot \Delta H_f
   \]

   \[
   Q_2 = 1.40 \, \text{kg} \cdot 105,000 \, \text{J kg}^{-1} = 147,000 \, \text{J}
   \]

3. **Calcular a energia total necessária:**

   \[
   Q_{\text{total}} = Q_1 + Q_2
   \]

   \[
   Q_{\text{total}} = 308,140.4 \, \text{J} + 147,000 \, \text{J} = 455,140.4 \, \text{J}
   \]

4. **Calcular a potência mínima necessária:**

   \[
   P = \frac{Q_{\text{total}}}{t}
   \]

   \[
   P = \frac{455,140.4 \, \text{J}}{600 \, \text{s}} = 758.57 \, \text{W}
   \]

A potência mínima necessária é aproximadamente $758.57 \, \text{W}$.
---
PROCESSED:
Para determinar a potência mínima necessária, precisamos calcular a energia total requerida para aquecer e fundir a prata, e depois dividir essa energia pelo tempo.

**Dados fornecidos:**

- Massa de prata, $m = 1.40 \, {kg}$
- Capacidade térmica mássica, $c = 235 \, {J kg}^{-1} {K}^{-1}$
- Ponto de fusão, $T_f = 961.8 \, {°C}$
- Variação de entalpia mássica de fusão, $\Delta H_f = 105 \, {kJ kg}^{-1} = 105,000 \, {J kg}^{-1}$
- Tempo, $t = 600 \, {s}$
- Temperatura inicial, $T_i = 25.0 \, {°C}$

**Passos de cálculo:**

1. **Calcular a energia necessária para aquecer a prata até o ponto de fusão:**
$
Q_1 = m  c  (T_f - T_i)
$
Q_1 = 1.40 \, {kg}  235 \, {J kg}^{-1} {K}^{-1}  (961.8 - 25.0) \, {K}
$
Q_1 = 1.40  235  936.8 = 308,140.4 \, {J}
$

2. **Calcular a energia necessária para fundir a prata:**
$
Q_2 = m  \Delta H_f
$
Q_2 = 1.40 \, {kg}  105,000 \, {J kg}^{-1} = 147,000 \, {J}
$

3. **Calcular a energia total necessária:**
$
Q_{{total}} = Q_1 + Q_2
$
Q_{{total}} = 308,140.4 \, {J} + 147,000 \, {J} = 455,140.4 \, {J}
$

4. **Calcular a potência mínima necessária:**
$
P = {Q_{{total}}}{t}
$
P = {455,140.4 \, {J}}{600 \, {s}} = 758.57 \, {W}
$

A potência mínima necessária é aproximadamente $758.57 \, {W}$.
===
---
ORIGINAL:
```csharp
using System.Threading;

public class SafeMessageBox<M> where M : class
{
    private class MsgHolder
    {
        internal readonly M msg;
        internal int lives;

        public MsgHolder(M message, int lvs)
        {
            msg = message;
            lives = lvs;
        }
    }

    private MsgHolder msgHolder = null;

    public void Publish(M m, int lvs)
    {
        Interlocked.Exchange(ref msgHolder, new MsgHolder(m, lvs));
    }

    public M TryConsume()
    {
        MsgHolder holder = msgHolder;
        if (holder != null && Interlocked.CompareExchange(ref holder.lives, holder.lives - 1, holder.lives) > 0)
        {
            return holder.msg;
        }
        return null;
    }
}
```
---
PROCESSED:
```csharp
using System.Threading;

public class SafeMessageBox<M> where M : class
{
    private class MsgHolder
    {
        internal readonly M msg;
        internal int lives;

        public MsgHolder(M message, int lvs)
        {
            msg = message;
            lives = lvs;
        }
    }

    private MsgHolder msgHolder = null;

    public void Publish(M m, int lvs)
    {
        Interlocked.Exchange(ref msgHolder, new MsgHolder(m, lvs));
    }

    public M TryConsume()
    {
        MsgHolder holder = msgHolder;
        if (holder != null && Interlocked.CompareExchange(ref holder.lives, holder.lives - 1, holder.lives) > 0)
        {
            return holder.msg;
        }
        return null;
    }
}
```
===
---
ORIGINAL:
Para determinar o volume mínimo da solução de HCl necessário, siga os passos abaixo:

1. **Reação do ouro com água régia:**

   A reação do ouro com água régia (mistura de HCl e HNO₃) pode ser representada por:

   $$ \text{Au} + 3 \text{HCl} + \text{HNO}_3 \rightarrow \text{H[AuCl}_4] + 2 \text{H}_2\text{O} $$

   Isso indica que 1 mol de Au reage com 3 mol de HCl.

2. **Cálculo dos mols de ouro:**

   Massa molar do ouro (Au) = 197 g/mol

   Mols de Au = \(\frac{60,0 \, \text{g}}{197 \, \text{g/mol}} \approx 0,304 \, \text{mol}\)

3. **Cálculo dos mols de HCl necessários:**

   De acordo com a estequiometria, são necessários 3 mols de HCl para cada mol de Au:

   Mols de HCl = \(0,304 \, \text{mol Au} \times 3 \approx 0,912 \, \text{mol HCl}\)

4. **Cálculo da massa de HCl necessária:**

   Massa de HCl = \(0,912 \, \text{mol} \times 36,46 \, \text{g/mol} \approx 33,25 \, \text{g}\)

5. **Cálculo do volume da solução de HCl:**

   A solução de HCl tem 37% em massa de HCl, então:

   Massa da solução = \(\frac{33,25 \, \text{g}}{0,37} \approx 89,86 \, \text{g}\)

6. **Cálculo do volume da solução:**

   Densidade da solução = 1,19 g/cm³

   Volume da solução = \(\frac{89,86 \, \text{g}}{1,19 \, \text{g/cm}^3} \approx 75,5 \, \text{cm}^3\)

Portanto, o volume mínimo da solução de HCl necessário é aproximadamente 75,5 cm³.
---
PROCESSED:
Para determinar o volume mínimo da solução de HCl necessário, siga os passos abaixo:

1. **Reação do ouro com água régia:**

   A reação do ouro com água régia (mistura de HCl e HNO₃) pode ser representada por:
$
{Au} + 3 {HCl} + {HNO}_3 \rightarrow {H[AuCl}_4] + 2 {H}_2{O}
$

   Isso indica que 1 mol de Au reage com 3 mol de HCl.

2. **Cálculo dos mols de ouro:**

   Massa molar do ouro (Au) = 197 g/mol

   Mols de Au = $\frac{60,0 \, {g}}{197 \, {g/mol}} \approx 0,304 \, {mol}$

3. **Cálculo dos mols de HCl necessários:**

   De acordo com a estequiometria, são necessários 3 mols de HCl para cada mol de Au:

   Mols de HCl = $0,304 \, {mol Au} \times 3 \approx 0,912 \, {mol HCl}$

4. **Cálculo da massa de HCl necessária:**

   Massa de HCl = $0,912 \, {mol} \times 36,46 \, {g/mol} \approx 33,25 \, {g}$

5. **Cálculo do volume da solução de HCl:**

   A solução de HCl tem 37% em massa de HCl, então:

   Massa da solução = $\frac{33,25 \, {g}}{0,37} \approx 89,86 \, {g}$

6. **Cálculo do volume da solução:**

   Densidade da solução = 1,19 g/cm³

   Volume da solução = $\frac{89,86 \, {g}}{1,19 \, {g/cm}^3} \approx 75,5 \, {cm}^3$

Portanto, o volume mínimo da solução de HCl necessário é aproximadamente 75,5 cm³.
===
